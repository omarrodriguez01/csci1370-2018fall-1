Build on what we know to write programs systematically:

- Design recipe
- Function structure follows data


We know we can produce solutions to even more complex functions if we just extend the simple rules we've learned so far



Complexity in 2 directions (and matching skill):

- Multiple parameters (identify data types from word problems)
- Multiple discrete steps to solve the problems (identify discrete steps)


Show worked solutions for motivation:


Rock, paper, scissors
Insurance premium


Review types of data (and templates) and introduce itemization



Practice identifying data types from word problems


- Notice: e.g. Temp can be atomic or interval based on context (c-to-f vs has-a-fever)



Demo: Rock, paper, scissors

Demo: Insurance premium

Data definitions:

Atomic data, Enumeration, Intervals

New templates!

New signatures!



Sidenote: Style

- function names: verbs, lowercase, - separated words
- variable names: same as functions, can be single letters or contractions
- type names (data definitions): camel case (note: don't use TypeName as variable-name!)
- indentation, dangling parentheses


Review: Enumeration, intervals

PI: Interval notation


Refactoring: improve code without changing behavior

Eliminate repeated code

- merge cond clauses
- use constants
- use helper functions

Good to have passing tests before performing refactoring, to make sure you don't introduce bugs










Itemizations


Examples: 

- happy new year countdown
- NorF
- AddableThing
- Rocket lift-off (countdown, then distance to earth)

Demo

Their turn, try



